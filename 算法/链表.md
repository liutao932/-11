# 链表



## 1.从尾到头打印链表

### 本题实现方法很多，可以逆置，可以用数组保存，本题推荐用递归

```c++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    void _printListFromTailToHead( vector<int> &v,ListNode* head)
    {
        if(head == nullptr)
            return ;
        _printListFromTailToHead(v,head->next);
        v.push_back(head->val);
    }
    vector<int> printListFromTailToHead(ListNode* head) {
          vector<int> v;
        _printListFromTailToHead(v,head);
        return v;
    }
};
```

## 2.删除链表倒数第k个节点

本题有个坑就是有三种情况，让链表从头走到尾，每移动一步，就让k值减1，当链表走到结尾时，如果k > 0 ，说明不用调整链表

当k == 0时，说明就是有节点，返回头结点的下一个节点，当k < 0 时，需要处理

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == nullptr ||n < 1) return head;
        ListNode * cur = head;
        while(cur != nullptr)
        {
            n--;
            cur = cur ->next;
        }
        if(n == 0)
        {
            return  head->next;
        }
      if(n < 0)
      {
            cur = head;
            while(++n != 0)
            {
                cur = cur -> next;
            }
            cur->next = cur->next->next;
        }
        return head;
    }
};
```

## 3.反转单链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
            ListNode* n1 = nullptr;
            ListNode* n2  = pHead;
            while(n2)
            {
                ListNode *n3 = n2 -> next;
                n2->next = n1;
                n1 = n2;
                n2 = n3;
            }
        return n1;
    }
};
```

## 4.反转部分单链表

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
ListNode *Reverse(struct ListNode*head)   //反转
{
    struct ListNode* n1 = NULL;
    struct ListNode* n2 = head;
    while(n2)
    {
        struct ListNode*n3 = n2->next;
        n2->next = n1;
        n1 = n2;
        n2 = n3;
    }
    return n1;
}
void Reverse1(struct ListNode*head)   //反转
{
    struct ListNode* n1 = NULL;
    struct ListNode* n2 = head;
    while(n2)
    {
        struct ListNode*n3 = n2->next;
        n2->next = n1;
        n1 = n2;
        n2 = n3;
    }
}
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if(head == nullptr || head->next == nullptr)  return head;
        ListNode* newhead = new ListNode(-1);
        newhead->next = head;
        ListNode* cur = newhead;
        
        ListNode* leftnode = nullptr, *leftprev = nullptr;
        for(int i = 0; i< m -1; ++i)
        {
            cur = cur->next;
        }
        leftprev = cur;
        leftnode = cur->next;    //找到左边的前屈节点和左边的反转节点
        
        cur = newhead;
        for(int i = 0;i<n;++i)
        {
            cur= cur->next;
        }
        ListNode * rigthnode = cur;    //找到右边的前屈节点和右边的反转节点
        ListNode * rigthnext = cur->next;
        
        
        leftprev->next = nullptr;    //断开连接，避免出现环
        rigthnode->next = nullptr;
        
        Reverse1(leftnode);
        /*ListNode* plist = Reverse(leftnode);
        ListNode* tail = plist;
        while(tail->next != nullptr)
        {
            tail = tail ->next;
        }
        leftprev->next = plist;   
        tail->next = rigthnext;
        */
        leftprev->next = rigthnode;     //连接链表
        leftnode->next = rigthnext;
        return newhead->next;
    }
};
```

## 5.环性单链表的约瑟夫问题

![image-20220307225419204](C:\Users\12585\AppData\Roaming\Typora\typora-user-images\image-20220307225419204.png)

```
class Solution {
public:
    /**
     * 
     * @param n int整型 
     * @param m int整型 
     * @return int整型
    */
  struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};
    int ysf(int n, int m) {
        ListNode* head = new ListNode(-1);
        ListNode* tail = head;
        for(int i = 1; i<= n; ++i)       //创建一个环形的单链表
        {
            tail->next = new ListNode(i);     
            tail = tail ->next;
        }
        ListNode* begin = head->next;
        tail->next = begin;
        int count = 0;
        while(tail != begin)
        {
            if(++count == m)    //判断如果等于m ，就可以删除m位置的节点
            {
                tail->next = begin->next;
                 count = 0;  //删除完毕后重新开始
            }
            else{
                tail = tail ->next;
            }
            begin = begin->next;
        }
        return begin->val;
    }
};
```

